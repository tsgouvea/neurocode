
# coding: utf-8

# In[1]:


import pandas as pd
import numpy as np
import matplotlib as mp
import scipy as sp
import os
import re
from sys import argv
import readTrodesExtractedDataFile


# In[2]:

"""
# Main function
def readTrodesExtractedDataFile(filename):

    with open(filename, 'rb') as f:
        # Check if first line is start of settings block
        if f.readline().decode('ascii').strip() != '<Start settings>':
            raise Exception("Settings format not supported")
        buff = ''
        c = 0.0
        fields = True
        fieldsText = {}
        for line in f:
            # Read through block of settings
            if(fields):
                line = line.decode('ascii').strip()

                # filling in fields dict
                if line != '<End settings>':
                    vals = line.split(': ')
                    fieldsText.update({vals[0].lower(): vals[1]})

                # End of settings block, signal end of fields
                else:
                    fields = False
                    dt = parseFields(fieldsText['fields'])
                    fieldsText['data'] = np.zeros([1], dtype = dt)

            else:
                # Holds the data in next line
                dat = line
                buff += dat
                c += float(len(dat)) / float(dt.itemsize)
                # data = np.frombuffer(buffer=dat, dtype=dt, count=c)
                # merged = np.concatenate([fieldsText['data'], data])
                # fieldsText.update({'data': merged})

        # Reads rest of file at once, using dtype format generated by parseFields()
        # dt = parseFields(fieldsText['fields'])
        data = np.frombuffer(buffer=buff, dtype=dt, count=int(round(c)))
        fieldsText.update({'data': data})
        # fieldsText.update({'data': np.delete(fieldsText['data'], 0, axis = 0)})
        return fieldsText


# Parses last fields parameter (<time uint32><...>) as a single string
# Assumes it is formatted as <name number * type> or <name type>
# Returns: np.dtype
def parseFields(fieldstr):
    # Returns np.dtype from field string
    sep = re.split('\s', re.sub(r"\>\<|\>|\<", ' ', fieldstr).strip())
    # print(sep)
    typearr = []
    # Every two elmts is fieldname followed by datatype
    for i in range(0,sep.__len__(), 2):
        fieldname = sep[i]
        repeats = 1
        ftype = 'uint32'

        # Finds if a <num>* is included in datatype
        if sep[i+1].__contains__('*'):
            temptypes = re.split('\*', sep[i+1])

            # Results in the correct assignment, whether str is num*dtype or dtype*num
            ftype = temptypes[temptypes[0].isdigit()]
            repeats = int(temptypes[temptypes[1].isdigit()])
        else:
            ftype = sep[i+1]

        try:
            fieldtype = getattr(np, ftype)
        except AttributeError:
            print(ftype + " is not a valid field type.\n")
            exit(1)
        else:
            typearr.append((str(fieldname), fieldtype, repeats))
    return np.dtype(typearr)



# Testing function here---------------------
# fields = readTrodesExtractedDataFile('16ChannelRec.spikes_nt10.dat')
# print(fields['data'])

if argv.__len__() > 1:
    np.set_printoptions(threshold='nan')
    fields = readTrodesExtractedDataFile(argv[1])
    print(fields['data'])


"""
# In[3]:


pathNeurodata = "/Users/thiago/Neurodata"
animal = "TG020"
session = "TG020_20170926_160712"
pathLFP = os.path.join(pathNeurodata, "Preprocessed", animal, session, session + ".LFP")
filename = session + ".LFP_nt3ch1.dat"
pathfile = os.path.join(pathLFP,filename)
print(pathfile)


# In[4]:


print("/Users/thiago/Neurodata/Preprocessed/TG020/TG020_20170926_160712")


# In[5]:


fields = readTrodesExtractedDataFile(pathfile)
